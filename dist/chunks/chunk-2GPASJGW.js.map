{
  "version": 3,
  "sources": ["../../bin/live-reload.js", "../../src/utils/get-html-element.ts", "../../src/utils/util.ts"],
  "sourcesContent": ["new EventSource(`${SERVE_ORIGIN}/esbuild`).addEventListener(\"change\", () => location.reload());\n", "/**\n * Configuration options for HTML element selection utilities.\n */\ntype GetHtmlElementProps = {\n  /** CSS selector string to target the desired element(s) */\n  selector: string;\n  /** Optional parent element to scope the search within. Defaults to document if not provided */\n  parent?: HTMLElement;\n  /** Logging level for when elements are not found. Set to false to disable logging */\n  log?: \"debug\" | \"error\" | false;\n};\n\n/**\n * Safely retrieves a single HTML element using a CSS selector with optional logging.\n *\n * @template TElement - The specific HTML element type to return (extends HTMLElement)\n * @param options - Configuration object for element selection\n * @param options.selector - CSS selector string to target the desired element\n * @param options.parent - Optional parent element to scope the search within\n * @param options.log - Logging level when element is not found (\"debug\", \"error\", or false)\n * @returns The found HTML element cast to the specified type, or null if not found\n *\n * @example\n * ```typescript\n * // Get a button element with error logging\n * const button = getHtmlElement<HTMLButtonElement>({\n *   selector: '.submit-btn',\n *   log: 'error'\n * });\n *\n * // Get an element within a specific parent with debug logging\n * const input = getHtmlElement<HTMLInputElement>({\n *   selector: 'input[type=\"email\"]',\n *   parent: formElement,\n *   log: 'debug'\n * });\n *\n * // Silent mode - no logging\n * const element = getHtmlElement({\n *   selector: '.optional-element',\n *   log: false\n * });\n * ```\n */\nexport const getHtmlElement = <TElement extends HTMLElement = HTMLElement>({\n  selector,\n  parent,\n  log = \"debug\",\n}: GetHtmlElementProps): TElement | null => {\n  const targetElement = (parent || document).querySelector<TElement>(selector);\n\n  if (targetElement === null) {\n    if (log === false) return null;\n    const consoleMethod = log === \"debug\" ? console.debug : console.error;\n    consoleMethod(\n      `${log.toUpperCase()}: Element with selector \"${selector}\" not found in ${\n        parent !== undefined ? \"the specified parent element:\" : \"the document.\"\n      }`,\n      parent\n    );\n    return null;\n  }\n\n  return targetElement;\n};\n\n/**\n * Safely retrieves multiple HTML elements using a CSS selector with optional logging.\n *\n * @template TElement - The specific HTML element type for array items (extends HTMLElement)\n * @param options - Configuration object for element selection\n * @param options.selector - CSS selector string to target the desired elements\n * @param options.parent - Optional parent element to scope the search within\n * @param options.log - Logging level when no elements are found (\"debug\", \"error\", or false)\n * @returns Array of found HTML elements cast to the specified type, or null if none found\n *\n * @example\n * ```typescript\n * // Get all list items with debug logging\n * const listItems = getMultipleHtmlElements<HTMLLIElement>({\n *   selector: 'li.item',\n *   log: 'debug'\n * });\n *\n * // Get all inputs within a form with error logging\n * const inputs = getMultipleHtmlElements<HTMLInputElement>({\n *   selector: 'input',\n *   parent: formElement,\n *   log: 'error'\n * });\n *\n * // Silent mode - no logging when elements not found\n * const buttons = getMultipleHtmlElements<HTMLButtonElement>({\n *   selector: '.action-btn',\n *   log: false\n * });\n * ```\n */\nexport const getMultipleHtmlElements = <TElement extends HTMLElement = HTMLElement>({\n  selector,\n  parent,\n  log = \"debug\",\n}: GetHtmlElementProps): TElement[] | null => {\n  const targetElements = Array.from((parent || document).querySelectorAll<TElement>(selector));\n\n  if (targetElements.length === 0) {\n    if (log === false) return null;\n    const consoleMethod = log === \"debug\" ? console.debug : console.error;\n    consoleMethod(\n      `${log.toUpperCase()}: No elements found with selector \"${selector}\" in ${\n        parent !== undefined ? \"the specified parent element:\" : \"the document.\"\n      }`,\n      parent\n    );\n    return null;\n  }\n\n  return targetElements;\n};\n", "type NonUndefined<T> = T extends undefined ? never : T;\n\nexport const fallback = <T>(\n  value: T,\n  replacementValue: NonUndefined<T>,\n  condition?: (value: T) => boolean\n) => {\n  if (value !== undefined && condition && !condition(value)) return replacementValue;\n  if (value === undefined || Number.isNaN(value)) return replacementValue;\n  if (value === 0) return value;\n\n  return value;\n};\n\nexport const parseFloatFallback = (inputStr: string | undefined, fallbackValue: number) => {\n  if (inputStr === undefined) return fallbackValue;\n\n  const parsedValue = Number.parseFloat(inputStr);\n\n  return Number.isNaN(parsedValue) ? fallbackValue : parsedValue;\n};\n\n/**\n * Checks if the current scroll position is below a given HTML element\n * @param element - The HTML element to check against\n * @param offset - Optional offset to add to the element's bottom position (default: 0)\n * @returns true if scroll position is below the element, false otherwise\n */\nexport const isScrollBelowElement = (element: HTMLElement, offset: number = 0): boolean => {\n  if (!element) return false;\n\n  // Get the element's position relative to the viewport\n  const elementRect = element.getBoundingClientRect();\n\n  // Get current scroll position\n  const scrollTop = window.scrollY || document.documentElement.scrollTop;\n\n  // Calculate the element's bottom position relative to the document\n  const elementBottom = elementRect.bottom + scrollTop - elementRect.height + offset;\n\n  // Check if current scroll position is below the element's bottom\n  return scrollTop > elementBottom;\n};\n"],
  "mappings": ";AAAA,IAAI,YAAY,GAAG,uBAAY,UAAU,EAAE,iBAAiB,UAAU,MAAM,SAAS,OAAO,CAAC;;;AC4CtF,IAAM,iBAAiB,CAA6C;AAAA,EACzE;AAAA,EACA;AAAA,EACA,MAAM;AACR,MAA4C;AAC1C,QAAM,iBAAiB,UAAU,UAAU,cAAwB,QAAQ;AAE3E,MAAI,kBAAkB,MAAM;AAC1B,QAAI,QAAQ,MAAO,QAAO;AAC1B,UAAM,gBAAgB,QAAQ,UAAU,QAAQ,QAAQ,QAAQ;AAChE;AAAA,MACE,GAAG,IAAI,YAAY,CAAC,4BAA4B,QAAQ,kBACtD,WAAW,SAAY,kCAAkC,eAC3D;AAAA,MACA;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAkCO,IAAM,0BAA0B,CAA6C;AAAA,EAClF;AAAA,EACA;AAAA,EACA,MAAM;AACR,MAA8C;AAC5C,QAAM,iBAAiB,MAAM,MAAM,UAAU,UAAU,iBAA2B,QAAQ,CAAC;AAE3F,MAAI,eAAe,WAAW,GAAG;AAC/B,QAAI,QAAQ,MAAO,QAAO;AAC1B,UAAM,gBAAgB,QAAQ,UAAU,QAAQ,QAAQ,QAAQ;AAChE;AAAA,MACE,GAAG,IAAI,YAAY,CAAC,sCAAsC,QAAQ,QAChE,WAAW,SAAY,kCAAkC,eAC3D;AAAA,MACA;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;ACpHO,IAAM,WAAW,CACtB,OACA,kBACA,cACG;AACH,MAAI,UAAU,UAAa,aAAa,CAAC,UAAU,KAAK,EAAG,QAAO;AAClE,MAAI,UAAU,UAAa,OAAO,MAAM,KAAK,EAAG,QAAO;AACvD,MAAI,UAAU,EAAG,QAAO;AAExB,SAAO;AACT;AAEO,IAAM,qBAAqB,CAAC,UAA8B,kBAA0B;AACzF,MAAI,aAAa,OAAW,QAAO;AAEnC,QAAM,cAAc,OAAO,WAAW,QAAQ;AAE9C,SAAO,OAAO,MAAM,WAAW,IAAI,gBAAgB;AACrD;AAQO,IAAM,uBAAuB,CAAC,SAAsB,SAAiB,MAAe;AACzF,MAAI,CAAC,QAAS,QAAO;AAGrB,QAAM,cAAc,QAAQ,sBAAsB;AAGlD,QAAM,YAAY,OAAO,WAAW,SAAS,gBAAgB;AAG7D,QAAM,gBAAgB,YAAY,SAAS,YAAY,YAAY,SAAS;AAG5E,SAAO,YAAY;AACrB;",
  "names": []
}
