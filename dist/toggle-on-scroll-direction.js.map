{
  "version": 3,
  "sources": ["../src/features/toggle-on-scroll-direction.ts"],
  "sourcesContent": ["import { fallback, parseFloatFallback } from \"@/utils/util\";\n\n/**\n * Initializes navbar behavior that toggles a class based on scroll direction.\n * The navbar can be hidden when scrolling down and shown when scrolling up.\n */\nconst init = () => {\n  // Select the navbar element that has the data-navbar attribute\n  const navbar = document.querySelector<HTMLDivElement>(\"[data-navbar]\");\n\n  if (!navbar) {\n    console.debug(\"[data-navbar] not found!\");\n    return;\n  }\n\n  // Get configuration from data attributes with fallback values\n  // initialOffset: how far the user needs to scroll before the behavior activates\n  const initialOffset = parseFloatFallback(navbar.dataset.scrollDirectionInitialOffset, 160);\n  // targetTriggerClass: the CSS class to add/remove when scrolling\n  const targetTriggerClass = fallback(navbar.dataset.scrollDirectionTriggerClass, \"scrolled-down\");\n  // Reset threshold: position at which we reset the initialOffset check (defaults to 10px)\n  const resetThreshold = 10;\n\n  // Track the last scroll position to determine scroll direction\n  let lastScrollTop: number = window.scrollY || document.documentElement.scrollTop;\n  // Flag to track if we've scrolled past the initial offset\n  let hasPassedInitialOffset = false;\n  // Flag to avoid repeatedly adding/removing the class\n  let hasClassAdded = false;\n\n  window.addEventListener(\n    \"scroll\",\n    () => {\n      // Get current scroll position\n      const scrollPosition: number = window.scrollY || document.documentElement.scrollTop;\n\n      // Reset the initialOffset check when close to the top of the page\n      if (scrollPosition <= resetThreshold) {\n        hasPassedInitialOffset = false;\n        // Also remove the class if it's added\n        if (hasClassAdded) {\n          navbar.classList.remove(targetTriggerClass);\n          hasClassAdded = false;\n        }\n      }\n\n      // Only activate behavior after scrolling past initialOffset\n      if (!hasPassedInitialOffset) {\n        if (scrollPosition >= initialOffset) {\n          hasPassedInitialOffset = true;\n          lastScrollTop = scrollPosition;\n        }\n        return;\n      }\n\n      // Determine scroll direction (down or up)\n      const scrollDirection = scrollPosition > lastScrollTop ? \"down\" : \"up\";\n\n      // When scrolling down, add the class to hide the navbar\n      if (scrollDirection === \"down\" && !hasClassAdded) {\n        navbar.classList.add(targetTriggerClass);\n        hasClassAdded = true;\n      }\n      // When scrolling up, remove the class to show the navbar\n      else if (scrollDirection === \"up\" && hasClassAdded) {\n        navbar.classList.remove(targetTriggerClass);\n        hasClassAdded = false;\n      }\n\n      // Update the last scroll position, ensuring it never goes below 0\n      lastScrollTop = scrollPosition <= 0 ? 0 : scrollPosition;\n    },\n    { passive: true } // Optimize scroll performance\n  );\n};\n\n// Run the initialization function\ninit();\n"],
  "mappings": ";;;;;;AAMA,IAAM,OAAO,MAAM;AAEjB,QAAM,SAAS,SAAS,cAA8B,eAAe;AAErE,MAAI,CAAC,QAAQ;AACX,YAAQ,MAAM,0BAA0B;AACxC;AAAA,EACF;AAIA,QAAM,gBAAgB,mBAAmB,OAAO,QAAQ,8BAA8B,GAAG;AAEzF,QAAM,qBAAqB,SAAS,OAAO,QAAQ,6BAA6B,eAAe;AAE/F,QAAM,iBAAiB;AAGvB,MAAI,gBAAwB,OAAO,WAAW,SAAS,gBAAgB;AAEvE,MAAI,yBAAyB;AAE7B,MAAI,gBAAgB;AAEpB,SAAO;AAAA,IACL;AAAA,IACA,MAAM;AAEJ,YAAM,iBAAyB,OAAO,WAAW,SAAS,gBAAgB;AAG1E,UAAI,kBAAkB,gBAAgB;AACpC,iCAAyB;AAEzB,YAAI,eAAe;AACjB,iBAAO,UAAU,OAAO,kBAAkB;AAC1C,0BAAgB;AAAA,QAClB;AAAA,MACF;AAGA,UAAI,CAAC,wBAAwB;AAC3B,YAAI,kBAAkB,eAAe;AACnC,mCAAyB;AACzB,0BAAgB;AAAA,QAClB;AACA;AAAA,MACF;AAGA,YAAM,kBAAkB,iBAAiB,gBAAgB,SAAS;AAGlE,UAAI,oBAAoB,UAAU,CAAC,eAAe;AAChD,eAAO,UAAU,IAAI,kBAAkB;AACvC,wBAAgB;AAAA,MAClB,WAES,oBAAoB,QAAQ,eAAe;AAClD,eAAO,UAAU,OAAO,kBAAkB;AAC1C,wBAAgB;AAAA,MAClB;AAGA,sBAAgB,kBAAkB,IAAI,IAAI;AAAA,IAC5C;AAAA,IACA,EAAE,SAAS,KAAK;AAAA;AAAA,EAClB;AACF;AAGA,KAAK;",
  "names": []
}
