{
  "version": 3,
  "sources": ["../src/utils/detect-scroll-amount.ts", "../src/features/toggle-after-target-scroll.ts"],
  "sourcesContent": ["/**\n * Detects if the page has been scrolled past a certain vertical length using Intersection Observer.\n * Does NOT use the window 'scroll' event.\n *\n * @param scrollYThreshold - The number of pixels from the top to detect if the user has scrolled past.\n * @param callback - Function called with `true` if scrolled past threshold, `false` otherwise.\n * @returns cleanup function to disconnect observer and remove marker\n */\nexport function detectScrollAmount(\n  scrollYThreshold: number,\n  callback: (beforeTargetScroll: boolean) => void\n): () => void {\n  // Create or get a marker element at the threshold position\n  let marker = document.createElement(\"div\");\n  marker.style.position = \"absolute\";\n  marker.style.top = `${scrollYThreshold}px`;\n  marker.style.left = \"0\";\n  marker.style.width = \"1px\";\n  marker.style.height = \"1px\";\n  marker.style.pointerEvents = \"none\";\n  marker.style.zIndex = \"-1\";\n  marker.setAttribute(\"data-scroll-threshold-marker\", \"true\");\n\n  // Avoid duplicating marker if already present\n  if (!document.body.querySelector(\"[data-scroll-threshold-marker]\")) {\n    document.body.appendChild(marker);\n  } else {\n    marker = document.body.querySelector(\"[data-scroll-threshold-marker]\") as HTMLDivElement;\n  }\n\n  // Helper to detect immediately on page load\n  function isPastThreshold(): boolean {\n    const rect = marker.getBoundingClientRect();\n    return rect.top < 0;\n  }\n\n  // Initial check\n  callback(isPastThreshold());\n\n  // Set up Intersection Observer\n  const observer = new IntersectionObserver(\n    ([entry]) => {\n      if (!entry) return;\n      // If the marker is not intersecting, it means we've scrolled past it\n      callback(entry.isIntersecting);\n    },\n    {\n      root: null,\n      threshold: 0,\n    }\n  );\n\n  observer.observe(marker);\n\n  // Cleanup function\n  return () => {\n    observer.disconnect();\n    if (marker.parentNode) marker.parentNode.removeChild(marker);\n  };\n}\n", "import { detectScrollAmount } from \"@/utils/detect-scroll-amount\";\nimport { getHtmlElement, getMultipleHtmlElements } from \"@/utils/get-html-element\";\nimport { createScrolledPastObserver, fallback, parseFloatFallback } from \"@/utils/util\";\n\n/**\n * Initializes scroll-based class and CSS variable toggling functionality\n * This feature allows elements to change appearance when the user scrolls\n * past a certain point on the page.\n */\nconst init = () => {\n  // Find all elements that should respond to scroll position\n  const toggleAfterTargetScrollElements = getMultipleHtmlElements({\n    selector: \"[data-toggle-after-target-scroll-element]\",\n  });\n\n  if (!toggleAfterTargetScrollElements) return;\n\n  const initialOffsetElement = getHtmlElement({\n    selector: \"[after-target-scroll-offset-element]\",\n    log: false,\n  });\n\n  // Set up scroll detection for each target element\n  for (const targetElement of toggleAfterTargetScrollElements) {\n    // Get configuration from data attributes\n    // The scroll offset at which the toggle should occur (defaults to 100px)\n    const initialOffset = parseFloatFallback(targetElement.dataset.afterScrollInitialOffset, 100);\n\n    // The class to add when scrolled beyond the offset (defaults to 'scrolled-below')\n    const targetTriggerClass = fallback(\n      targetElement.dataset.afterScrollTriggerClass,\n      \"scrolled-below\"\n    );\n\n    if (initialOffsetElement) {\n      createScrolledPastObserver(initialOffsetElement, (hasScrollPast) => {\n        if (hasScrollPast) {\n          targetElement.classList.add(targetTriggerClass);\n        } else {\n          targetElement.classList.remove(targetTriggerClass);\n        }\n      });\n      continue;\n    }\n\n    detectScrollAmount(initialOffset, (beforeTargetScroll) => {\n      if (beforeTargetScroll) {\n        // User is above the scroll threshold\n        targetElement.classList.remove(targetTriggerClass);\n      } else {\n        // User has scrolled beyond the threshold\n        targetElement.classList.add(targetTriggerClass);\n      }\n    });\n  }\n};\n\n// Start the feature when the file loads\ninit();\n"],
  "mappings": ";;;;;;;;;AAQO,SAAS,mBACd,kBACA,UACY;AAEZ,MAAI,SAAS,SAAS,cAAc,KAAK;AACzC,SAAO,MAAM,WAAW;AACxB,SAAO,MAAM,MAAM,GAAG,gBAAgB;AACtC,SAAO,MAAM,OAAO;AACpB,SAAO,MAAM,QAAQ;AACrB,SAAO,MAAM,SAAS;AACtB,SAAO,MAAM,gBAAgB;AAC7B,SAAO,MAAM,SAAS;AACtB,SAAO,aAAa,gCAAgC,MAAM;AAG1D,MAAI,CAAC,SAAS,KAAK,cAAc,gCAAgC,GAAG;AAClE,aAAS,KAAK,YAAY,MAAM;AAAA,EAClC,OAAO;AACL,aAAS,SAAS,KAAK,cAAc,gCAAgC;AAAA,EACvE;AAGA,WAAS,kBAA2B;AAClC,UAAM,OAAO,OAAO,sBAAsB;AAC1C,WAAO,KAAK,MAAM;AAAA,EACpB;AAGA,WAAS,gBAAgB,CAAC;AAG1B,QAAM,WAAW,IAAI;AAAA,IACnB,CAAC,CAAC,KAAK,MAAM;AACX,UAAI,CAAC,MAAO;AAEZ,eAAS,MAAM,cAAc;AAAA,IAC/B;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,WAAW;AAAA,IACb;AAAA,EACF;AAEA,WAAS,QAAQ,MAAM;AAGvB,SAAO,MAAM;AACX,aAAS,WAAW;AACpB,QAAI,OAAO,WAAY,QAAO,WAAW,YAAY,MAAM;AAAA,EAC7D;AACF;;;AClDA,IAAM,OAAO,MAAM;AAEjB,QAAM,kCAAkC,wBAAwB;AAAA,IAC9D,UAAU;AAAA,EACZ,CAAC;AAED,MAAI,CAAC,gCAAiC;AAEtC,QAAM,uBAAuB,eAAe;AAAA,IAC1C,UAAU;AAAA,IACV,KAAK;AAAA,EACP,CAAC;AAGD,aAAW,iBAAiB,iCAAiC;AAG3D,UAAM,gBAAgB,mBAAmB,cAAc,QAAQ,0BAA0B,GAAG;AAG5F,UAAM,qBAAqB;AAAA,MACzB,cAAc,QAAQ;AAAA,MACtB;AAAA,IACF;AAEA,QAAI,sBAAsB;AACxB,iCAA2B,sBAAsB,CAAC,kBAAkB;AAClE,YAAI,eAAe;AACjB,wBAAc,UAAU,IAAI,kBAAkB;AAAA,QAChD,OAAO;AACL,wBAAc,UAAU,OAAO,kBAAkB;AAAA,QACnD;AAAA,MACF,CAAC;AACD;AAAA,IACF;AAEA,uBAAmB,eAAe,CAAC,uBAAuB;AACxD,UAAI,oBAAoB;AAEtB,sBAAc,UAAU,OAAO,kBAAkB;AAAA,MACnD,OAAO;AAEL,sBAAc,UAAU,IAAI,kBAAkB;AAAA,MAChD;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAGA,KAAK;",
  "names": []
}
