{
  "version": 3,
  "sources": ["../src/utils/detect-scroll-amount.ts", "../src/utils/inject-css-variables.ts", "../src/features/toggle-after-target-scroll.ts"],
  "sourcesContent": ["/**\n * Detects if the page has been scrolled past a certain vertical length using Intersection Observer.\n * Does NOT use the window 'scroll' event.\n *\n * @param scrollYThreshold - The number of pixels from the top to detect if the user has scrolled past.\n * @param callback - Function called with `true` if scrolled past threshold, `false` otherwise.\n * @returns cleanup function to disconnect observer and remove marker\n */\nexport function detectScrollAmount(\n  scrollYThreshold: number,\n  callback: (beforeTargetScroll: boolean) => void\n): () => void {\n  // Create or get a marker element at the threshold position\n  let marker = document.createElement(\"div\");\n  marker.style.position = \"absolute\";\n  marker.style.top = `${scrollYThreshold}px`;\n  marker.style.left = \"0\";\n  marker.style.width = \"1px\";\n  marker.style.height = \"1px\";\n  marker.style.pointerEvents = \"none\";\n  marker.style.zIndex = \"-1\";\n  marker.setAttribute(\"data-scroll-threshold-marker\", \"true\");\n\n  // Avoid duplicating marker if already present\n  if (!document.body.querySelector(\"[data-scroll-threshold-marker]\")) {\n    document.body.appendChild(marker);\n  } else {\n    marker = document.body.querySelector(\"[data-scroll-threshold-marker]\") as HTMLDivElement;\n  }\n\n  // Helper to detect immediately on page load\n  function isPastThreshold(): boolean {\n    const rect = marker.getBoundingClientRect();\n    return rect.top < 0;\n  }\n\n  // Initial check\n  callback(isPastThreshold());\n\n  // Set up Intersection Observer\n  const observer = new IntersectionObserver(\n    ([entry]) => {\n      if (!entry) return;\n      // If the marker is not intersecting, it means we've scrolled past it\n      callback(entry.isIntersecting);\n    },\n    {\n      root: null,\n      threshold: 0,\n    }\n  );\n\n  observer.observe(marker);\n\n  // Cleanup function\n  return () => {\n    observer.disconnect();\n    if (marker.parentNode) marker.parentNode.removeChild(marker);\n  };\n}\n", "/**\n * Injects custom CSS variables into a target element, overwriting any existing variables with the same names.\n *\n * @param element The target HTMLElement to which CSS variables will be applied.\n * @param variables An object mapping CSS variable names (e.g., '--main-color') to their values.\n * @returns A function that will revert all the injected CSS variables.\n */\nexport function injectCssVariables(\n  element: HTMLElement,\n  variables: Record<string, string>\n): () => void {\n  // Keep track of which properties were injected\n  const injectedProps: string[] = [];\n\n  for (const [name, value] of Object.entries(variables)) {\n    if (name.startsWith(\"--\")) {\n      element.style.setProperty(name, value);\n      injectedProps.push(name);\n    }\n  }\n\n  // Return a revert function\n  return function revert(): void {\n    // Remove only the properties that were injected\n    for (const prop of injectedProps) {\n      element.style.removeProperty(prop);\n    }\n  };\n}\n\n// Usage example:\n// const revertFunc = injectCssVariables(myElement, { '--color': 'red', '--size': '20px' });\n// ... later ...\n// revertFunc(); // Removes the injected properties\n", "import { detectScrollAmount } from \"@/utils/detect-scroll-amount\";\nimport { injectCssVariables } from \"@/utils/inject-css-variables\";\nimport { fallback, parseFloatFallback } from \"@/utils/util\";\n\n/**\n * Initializes scroll-based class and CSS variable toggling functionality\n * This feature allows elements to change appearance when the user scrolls\n * past a certain point on the page.\n */\nconst init = () => {\n  // Find all elements that should respond to scroll position\n  const toggleAfterTargetScrollElements = Array.from(\n    document.querySelectorAll<HTMLElement>(\"[data-toggle-after-target-scroll-element]\")\n  );\n\n  // Will be populated when wfVarModes is ready\n\n  // Set up scroll detection for each target element\n  for (const targetElement of toggleAfterTargetScrollElements) {\n    // Get configuration from data attributes\n    // The scroll offset at which the toggle should occur (defaults to 100px)\n    const initialOffset = parseFloatFallback(targetElement.dataset.afterScrollInitialOffset, 100);\n\n    // The class to add when scrolled beyond the offset (defaults to 'scrolled-below')\n    const targetTriggerClass = fallback(\n      targetElement.dataset.afterScrollTriggerClass,\n      \"scrolled-below\"\n    );\n\n    // Optional: variable mode to apply when scrolled beyond the offset\n    const targetTriggerVarMode = targetElement.dataset.afterScrollTriggerVarMode;\n\n    // Will hold the function that can revert injected CSS variables\n    let variableRemover: (() => void) | undefined = undefined;\n\n    if (targetTriggerVarMode !== undefined) {\n      let varModes = window.wfVarModes?.data;\n      let targetVarMode =\n        targetTriggerVarMode && varModes ? varModes[targetTriggerVarMode] : undefined;\n\n      window.addEventListener(\"wfVarModesReady\", (event) => {\n        varModes = event.detail.data;\n        targetVarMode = targetTriggerVarMode ? varModes[targetTriggerVarMode] : undefined;\n      });\n\n      detectScrollAmount(initialOffset, (beforeTargetScroll) => {\n        if (beforeTargetScroll) {\n          // User is above the scroll threshold\n          targetElement.classList.remove(targetTriggerClass);\n\n          // Remove any applied CSS variables with smooth transition\n          if (targetTriggerVarMode && variableRemover !== undefined) {\n            variableRemover();\n            variableRemover = undefined;\n          }\n        } else {\n          // User has scrolled beyond the threshold\n          targetElement.classList.add(targetTriggerClass);\n\n          // Apply CSS variables from the specified variable mode\n          if (targetTriggerVarMode && targetVarMode) {\n            // Inject variables and store the remover function for later use\n            variableRemover = injectCssVariables(targetElement, targetVarMode);\n          }\n        }\n      });\n\n      return;\n    }\n\n    detectScrollAmount(initialOffset, (beforeTargetScroll) => {\n      if (beforeTargetScroll) {\n        // User is above the scroll threshold\n        targetElement.classList.remove(targetTriggerClass);\n      } else {\n        // User has scrolled beyond the threshold\n        targetElement.classList.add(targetTriggerClass);\n      }\n    });\n  }\n};\n\n// Start the feature when the file loads\ninit();\n"],
  "mappings": ";;;;;;AAQO,SAAS,mBACd,kBACA,UACY;AAEZ,MAAI,SAAS,SAAS,cAAc,KAAK;AACzC,SAAO,MAAM,WAAW;AACxB,SAAO,MAAM,MAAM,GAAG,gBAAgB;AACtC,SAAO,MAAM,OAAO;AACpB,SAAO,MAAM,QAAQ;AACrB,SAAO,MAAM,SAAS;AACtB,SAAO,MAAM,gBAAgB;AAC7B,SAAO,MAAM,SAAS;AACtB,SAAO,aAAa,gCAAgC,MAAM;AAG1D,MAAI,CAAC,SAAS,KAAK,cAAc,gCAAgC,GAAG;AAClE,aAAS,KAAK,YAAY,MAAM;AAAA,EAClC,OAAO;AACL,aAAS,SAAS,KAAK,cAAc,gCAAgC;AAAA,EACvE;AAGA,WAAS,kBAA2B;AAClC,UAAM,OAAO,OAAO,sBAAsB;AAC1C,WAAO,KAAK,MAAM;AAAA,EACpB;AAGA,WAAS,gBAAgB,CAAC;AAG1B,QAAM,WAAW,IAAI;AAAA,IACnB,CAAC,CAAC,KAAK,MAAM;AACX,UAAI,CAAC,MAAO;AAEZ,eAAS,MAAM,cAAc;AAAA,IAC/B;AAAA,IACA;AAAA,MACE,MAAM;AAAA,MACN,WAAW;AAAA,IACb;AAAA,EACF;AAEA,WAAS,QAAQ,MAAM;AAGvB,SAAO,MAAM;AACX,aAAS,WAAW;AACpB,QAAI,OAAO,WAAY,QAAO,WAAW,YAAY,MAAM;AAAA,EAC7D;AACF;;;ACpDO,SAAS,mBACd,SACA,WACY;AAEZ,QAAM,gBAA0B,CAAC;AAEjC,aAAW,CAAC,MAAM,KAAK,KAAK,OAAO,QAAQ,SAAS,GAAG;AACrD,QAAI,KAAK,WAAW,IAAI,GAAG;AACzB,cAAQ,MAAM,YAAY,MAAM,KAAK;AACrC,oBAAc,KAAK,IAAI;AAAA,IACzB;AAAA,EACF;AAGA,SAAO,SAAS,SAAe;AAE7B,eAAW,QAAQ,eAAe;AAChC,cAAQ,MAAM,eAAe,IAAI;AAAA,IACnC;AAAA,EACF;AACF;;;ACnBA,IAAM,OAAO,MAAM;AAEjB,QAAM,kCAAkC,MAAM;AAAA,IAC5C,SAAS,iBAA8B,2CAA2C;AAAA,EACpF;AAKA,aAAW,iBAAiB,iCAAiC;AAG3D,UAAM,gBAAgB,mBAAmB,cAAc,QAAQ,0BAA0B,GAAG;AAG5F,UAAM,qBAAqB;AAAA,MACzB,cAAc,QAAQ;AAAA,MACtB;AAAA,IACF;AAGA,UAAM,uBAAuB,cAAc,QAAQ;AAGnD,QAAI,kBAA4C;AAEhD,QAAI,yBAAyB,QAAW;AACtC,UAAI,WAAW,OAAO,YAAY;AAClC,UAAI,gBACF,wBAAwB,WAAW,SAAS,oBAAoB,IAAI;AAEtE,aAAO,iBAAiB,mBAAmB,CAAC,UAAU;AACpD,mBAAW,MAAM,OAAO;AACxB,wBAAgB,uBAAuB,SAAS,oBAAoB,IAAI;AAAA,MAC1E,CAAC;AAED,yBAAmB,eAAe,CAAC,uBAAuB;AACxD,YAAI,oBAAoB;AAEtB,wBAAc,UAAU,OAAO,kBAAkB;AAGjD,cAAI,wBAAwB,oBAAoB,QAAW;AACzD,4BAAgB;AAChB,8BAAkB;AAAA,UACpB;AAAA,QACF,OAAO;AAEL,wBAAc,UAAU,IAAI,kBAAkB;AAG9C,cAAI,wBAAwB,eAAe;AAEzC,8BAAkB,mBAAmB,eAAe,aAAa;AAAA,UACnE;AAAA,QACF;AAAA,MACF,CAAC;AAED;AAAA,IACF;AAEA,uBAAmB,eAAe,CAAC,uBAAuB;AACxD,UAAI,oBAAoB;AAEtB,sBAAc,UAAU,OAAO,kBAAkB;AAAA,MACnD,OAAO;AAEL,sBAAc,UAAU,IAAI,kBAAkB;AAAA,MAChD;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAGA,KAAK;",
  "names": []
}
